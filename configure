#!/usr/bin/env bash

set -eu
set -o pipefail

. ./script/color.rc

APP_ROOT_PATH=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
IN_DOCKER=false

if grep -q docker /proc/1/cgroup; then
  IN_DOCKER=true
fi

$IN_DOCKER && exit 0

DOING_MSG=

function _doing() {
  DOING_MSG=$1

  echo "${blue}⇾ Doing « ${DOING_MSG} »…$resetColor"
}

function _done() {
  local DONE="${1:-DONE}"

  [ -z "$1" ] || DONE="$1"

  echo
  echo "${green}✓ ${resetColor} ${DOING_MSG} : ${green}$DONE${resetColor}"
  echo
}

function _doneNTD() {
  _done 'Nothing to do…'
}

function _warn() {
  echo
  echo "${yellow}⚠${resetColor} ${DOING_MSG} : ${bold}${yellow}$1${resetColor}${resetBold}"
  echo
}

function _exit() {
  [ "X$(basename "$0")" = "X$(basename "${BASH_SOURCE[0]}")" ] && exit "$1" || return "$1"
}

function _fail() {
  echo "$bold${red}⛌ PROCESS ABORTED${resetColor}${resetBold}"
  echo

  _exit 1
}

function _do() {
  # https://unix.stackexchange.com/questions/148109/shifting-command-output-to-the-right
  echo "Executing command '$1'"

  {
    if ! eval "$1" | nl -bn; then
      _fail
    fi
  }
}

function isConfigAppEnvNeeded() {
  [ ! -e "${APP_ROOT_PATH}/.envrc" ] || grep -q 'CONFIG_APP_ENV' "${APP_ROOT_PATH}/.envrc"
}

function configAppEnv() {
  local env_name
  local env_choice

  # shellcheck disable=SC2015
  isConfigAppEnvNeeded && {
    echo -e "\t${yellow}1${resetColor} : development\n"
    echo -e "\t${yellow}2${resetColor} : staging\n"
    echo -e "\t${yellow}3${resetColor} : production\n"
    echo -e "Enter your choice: \c"
    # shellcheck disable=SC2162
    read env_choice

    while [ -z "$env_choice" ] || [[ "$env_choice" != "1" && "$env_choice" != "2" && "$env_choice" != "3" ]]; do
      tput el
      echo -e "Unsupported choice, enter your choice : \c"
      # shellcheck disable=SC2162
      read env_choice

    done

    case $env_choice in
    1)
      env_name="development"
      ;;
    2)
      env_name="staging"
      ;;
    3)
      env_name="production"
      ;;
    esac

    sed -i "s/CONFIG_APP_ENV/${env_name}/g" "${APP_ROOT_PATH}/.envrc"
    cp "${APP_ROOT_PATH}/config_${env_name}.toml.example" "${APP_ROOT_PATH}/config_${env_name}.toml"

    _done
  } || _doneNTD

  [ -z "$env_name" ] || export APP_ENV=$env_name
}

_doing 'Configuration of APP_ENV'
# shellcheck disable=SC2015
if isConfigAppEnvNeeded; then
  cp "${APP_ROOT_PATH}/.envrc.example" "${APP_ROOT_PATH}/.envrc"
  configAppEnv
else
  _doneNTD
fi

# shellcheck disable=SC1091
. ./.envrc || exit 1

_doing 'Installing Mise-en-place'
if ! type mise &>/dev/null; then
  if type apt &>/dev/null; then
    sudo install -dm 755 /etc/apt/keyrings &&
      curl -fsSL https://mise.jdx.dev/gpg-key.pub | tee /etc/apt/keyrings/mise-archive-keyring.asc >/dev/null &&
      echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.asc] https://mise.jdx.dev/deb stable main" | tee /etc/apt/sources.list.d/mise.list &&
      apt-get update && apt-get install -y mise
  else
    curl https://mise.run | sh
  fi

  if [ "$SHELL" = "/bin/bash" ] || [ "$SHELL" = "/usr/bin/bash" ]; then
    cat <<'EOF' >>"$HOME/.bashrc"
type mise &>/dev/null && {
  eval "$(mise activate bash)"
  COMP_DIR="$HOME/.local/share/bash-completion/completions"
  [ -e "$COMP_DIR" ] || mkdir -p "$COMP_DIR"
  grep -q 'usage = "latest"' "$HOME/.config/mise/config.toml" 2>/dev/null || mise use -g usage@latest
  mise completion bash --include-bash-completion-lib >"$COMP_DIR/mise"
}
EOF
  elif [ "$SHELL" = "/bin/zsh" ] || [ "$SHELL" = "/usr/bin/zsh" ]; then
    cat <<'EOF' >>"$HOME/.zshrc"
type mise &>/dev/null && {
  eval "$(mise activate zsh)"
  COMP_DIR="$HOME/.local/share/zsh/completions"
  [ -e "$COMP_DIR" ] || mkdir -p "$COMP_DIR"
  grep -q 'usage = "latest"' "$HOME/.config/mise/config.toml" 2>/dev/null || mise use -g usage@latest
  mise completion zsh >"$COMP_DIR/_mise"
  # Add to fpath if not already present
  [[ ":$FPATH:" != *":$COMP_DIR:"* ]] && fpath=("$COMP_DIR" $fpath)
}
EOF
  fi
else
  _doneNTD
fi

mise settings experimental=true
mise install
